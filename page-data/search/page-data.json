{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"문제 링크 문제에 설명된 절사평균이라는 개념을 잘 읽고 적용하면 풀릴 것 같은 문제지만, 파이썬에서 반올림에 흔히 사용되는  함수의 미묘한 특성을 알지 못하면 풀기 힘든 문제이다. round() 보통 우리가 보편적으로 알고 있는 반올림 방식은 숫자 5 이상부터 올리고, 4 이하부터 내리는 방식인데, 파이썬의 반올림은 가까운 짝수 쪽으로 반올림 하는 방식을…","fields":{"slug":"/boj-18110/"},"frontmatter":{"date":"June 18, 2024","title":"python round() 와 반올림","tags":["Algorithm","Python"]},"rawMarkdownBody":"\n[문제 링크](https://www.acmicpc.net/problem/18110)\n\n문제에 설명된 절사평균이라는 개념을 잘 읽고 적용하면 풀릴 것 같은 문제지만, 파이썬에서 반올림에 흔히 사용되는 `round()` 함수의 미묘한 특성을 알지 못하면 풀기 힘든 문제이다.\n\n## **round()**\n\n보통 우리가 보편적으로 알고 있는 반올림 방식은 숫자 5 이상부터 올리고, 4 이하부터 내리는 방식인데, 파이썬의 반올림은 가까운 짝수 쪽으로 반올림 하는 방식을 사용한다.\n\n![](img1.png)\n\n파이썬 쉘에 숫자를 실제로 입력해 보면 생각했던 결과가 나오지 않는 것을 알 수 있다.\n\n## **풀이**\n\n```python\nimport sys\n\ndef n_round(num):\n    return int(num) + (1 if num - int(num) >= 0.5 else 0)\n\nn = int(sys.stdin.readline())\nif n == 0:\n    print(0)\nelse:\n    lst = sorted([int(sys.stdin.readline()) for i in range(n)])\n    excl = n_round(n * 0.15)\n    print(n_round(sum(lst[excl:n - excl]) / (n - 2 * excl)))\n```\n\n`n_round` 함수를 통해 우리가 흔히 사용하는 반올림 방식을 적용시켜서 풀었다.\n\n&nbsp;\n\n여담으로 파이썬에서 사용하는 방식의 반올림을 `은행가 반올림 (Banker’s rounding)` 이라고 하는데, 통계적으로 확률 차이를 줄여주기 때문에 숫자와 돈에 민감한 금융가에서 사용한다고 한다. 또한 파이썬에서만 사용되는 방식도 아니고, C# 과 Java 에서도 이 방식을 사용하고 있다고 한다.\n"},{"excerpt":"백준 사이트에서 알고리즘 문제를 풀 때는 다른 알고리즘 풀이 사이트와 다르게 입출력을 명시해 줘야 한다. 가장 기본적인 입력 함수는  이고, 좀 더 빠른 입력을 위해 사용하는 함수는  이다. 두 함수의 속도 차이를 크게 느낄 수 있는 문제 하나를 예시로 들자면 단어 정렬 문제 링크 단순 문자열 정렬 유형으로, 어렵지 않은 난이도의 문제이다.   처음 풀이…","fields":{"slug":"/boj-1181/"},"frontmatter":{"date":"June 11, 2024","title":"input() vs sys.stdin.readline()","tags":["Algorithm","Python"]},"rawMarkdownBody":"\n백준 사이트에서 알고리즘 문제를 풀 때는 다른 알고리즘 풀이 사이트와 다르게 입출력을 명시해 줘야 한다. 가장 기본적인 입력 함수는 `input()` 이고, 좀 더 빠른 입력을 위해 사용하는 함수는 `sys.stdin.readline()` 이다.\n\n두 함수의 속도 차이를 크게 느낄 수 있는 문제 하나를 예시로 들자면\n\n## **단어 정렬**\n\n[문제 링크](https://www.acmicpc.net/problem/1181)\n\n단순 문자열 정렬 유형으로, 어렵지 않은 난이도의 문제이다.\n\n&nbsp;\n\n### **처음 풀이**\n\n```python\nn = int(input())\nlst = list(set([input() for i in range(n)]))\nlst.sort(key=lambda x: (len(x), x))\nfor s in lst:\n    print(s)\n```\n\n`input()` 함수로 숫자 n 을 입력 받고, n 만큼 루프를 돌려서 역시 `input()` 함수를 통해 문자열을 입력받고, 중복 제거 후 조건에 따라 람다식을 이용해서 정렬 후 차례대로 출력했다.\n\n&nbsp;\n\n### **두번째 풀이**\n\n```python\nimport sys\n\nn = int(sys.stdin.readline())\nlst = list(set([sys.stdin.readline().strip() for i in range(n)]))\nlst.sort(key=lambda x: (len(x), x))\nfor s in lst:\n    print(s)\n```\n\n시간이 생각보다 오래 걸리는 것 같아서 입력 함수만 변경한 풀이이다.\n\n&nbsp;\n\n두 풀이의 결과는 다음과 같다.\n\n&nbsp;\n\n![](img1.png)\n\n아래부터 첫 번째 풀이의 결과인데, 겨우 입력 함수만 변경했을 뿐인데 시간 차이가 무려 10배 가까이 났다.\n\n그냥 어렴풋이 `sys.stdin.readline()` 가 빠르다.. 정도만 인식하고 있었는데, 속도 차이가 급격하게 나는 것을 경험한 뒤로는 문제 풀 때 더 이상 기본 `input()` 함수는 사용하지 않고 있다. 뿐만 아니라, 시간제한 기준이 짧은 조금 더 어려운 난이도의 문제를 풀 때는 반드시 `sys.stdin.readline()` 함수를 사용해야 시간 초과가 나지 않았다.\n\n&nbsp;\n\n&nbsp;\n\n### **input()**\n\nide 에서 `input()` 의 설명을 찾아보면 다음과 같다.\n\n![](img2.png)\n\n외부로부터 입력을 받으면 문자열 끝에 오는 줄 바꿈 문자(\\n) 를 제거한다는 내용이다. 또한, 입력을 받기 전 보여주는 프롬포트 문자열을 출력할 수 있다. 또 한 가지 특징은 `input()` 함수는 입력의 끝 (EOF) 을 만났을 때 EOFError를 던져준다.\n\n&nbsp;\n\n&nbsp;\n\n### **sys.stdin.readline()**\n\nw3school 에서 `readline()` 의 정의를 찾아보면 다음과 같다.\n\n![](img3.png)\n\n외부로부터 입력을 받으면 한 줄을 그대로 읽어오기 때문에 줄 바꿈 문자(\\n) 를 따로 제거하지 않는다. 이러한 특성 때문에 문자열 입력을 여러 개 받을 때는 `strip()` 함수를 추가로 붙여서 줄 바꿈 문자를 제거하게끔 작성해야 한다.\n\n그리고 `input()` 함수와 달리 입력이 끝났어도 따로 에러를 던져주지 않기 때문에 아주 가끔 에러를 발생시켜야 통과되는 문제에서는 `input()` 함수를 사용해야만 한다.\n"},{"excerpt":"동기 처리와 비동기 처리 실행 컨텍스트  함수가 실행되려면  에서 생성된 함수 실행 컨텍스트가 실행 컨텍스트 스택에 푸시되어야 한다. 즉, 실행 컨텍스트 스택에 함수 실행 컨텍스트가 푸시되는 것은 바로 함수 실행의 시작을 의미한다. 함수가 호출된 순서대로 순차적으로 실행되는 이유는 함수가 호출된 순서대로 함수 실행 컨텍스트가 실행 컨텍스트 스택에 푸시되기…","fields":{"slug":"/asynchronous-programming/"},"frontmatter":{"date":"June 05, 2024","title":"비동기 프로그래밍","tags":["Javascript"]},"rawMarkdownBody":"\n## **동기 처리와 비동기 처리**\n\n### **실행 컨텍스트**\n\n![](img1.png)\n\n함수가 실행되려면 `함수 코드 평가 과정` 에서 생성된 함수 실행 컨텍스트가 실행 컨텍스트 스택에 푸시되어야 한다. 즉, 실행 컨텍스트 스택에 함수 실행 컨텍스트가 푸시되는 것은 바로 함수 실행의 시작을 의미한다. 함수가 호출된 순서대로 순차적으로 실행되는 이유는 함수가 호출된 순서대로 함수 실행 컨텍스트가 실행 컨텍스트 스택에 푸시되기 때문이다. 이처럼 함수 실행 순서는 실행 컨텍스트 스택으로 관리한다.\n\n자바스크립트 엔진은 단 하나의 실행 컨텍스트 스택을 갖는다. 이는 함수를 실행할 수 있는 창구가 단 하나이며, 동시에 2개 이상의 함수를 실행할 수 없다는 것을 의미한다. 실행 컨텍스트 스택의 최상위 요소인 \"실행 중인 실행 컨텍스트\" 를 제외한 모든 실행 컨텍스트는 모두 실행 대기 중인 태스크들이다. 대기 중인 태스크들은 현재 실행 중인 실행 컨텍스트가 팝되어 실행 컨텍스트 스택에서 제거되면, 즉 현재 실행 중인 함수가 종료하면 실행되기 시작한다. 자바스크립트 엔진은 한 번에 하나의 태스크만 실행할 수 있는 싱글 스레드 방식으로 동작하므로 처리에 시간이 걸리는 태스크를 실행하는 경우 블로킹(작업 중단)이 발생한다.\n\n&nbsp;\n\n### **동기(Synchronous) 처리**\n\n```javascript\n// sleep 함수는 일정 시간(delay)이 경과한 이후에 콜백 함수(func)를 호출한다.\nfunction sleep(func, delay) {\n  const delayUntil = Date.now() + delay;\n  while (Date.now() < delayUntil);\n  func();\n}\n\nfunction foo() {\n  console.log(\"foo\");\n}\n\nfunction bar() {\n  console.log(\"bar\");\n}\n\n// sleep 함수는 3초 이상 실행된다.\nsleep(foo, 3 * 1000);\n\n// bar 함수는 sleep 함수의 실행이 종료된 이후에 호출되므로 3초 이상 블로킹 된다.\nbar();\n\n// (3초 경과 후) foo 호출 -> bar 호출\n```\n\n위 예제의 sleep 함수는 3초 후에 foo 함수를 호출한다. 이때 bar 함수는 sleep 함수의 실행이 종료된 이후에 호출되므로 3초 이상(foo 함수의 실행 시간 + 3초) 호출되지 못하고 블로킹된다.이처럼 `현재 실행 중인 태스크가 종료할 때까지 다음에 실행될 태스크가 대기하는 방식을 동기(Synchronous)처리`라고 한다\n\n&nbsp;\n\n![](img5.png)\n\n동기 처리 방식은 태스크를 순서대로 하나씩 처리하므로 실행 순서가 보장된다는 장점이 있지만, 앞선 태스크가 종료할 때까지 이후 태스크들이 블로킹되는 단점이 있다.\n\n&nbsp;\n\n&nbsp;\n\n### **비동기(Asynchronous) 처리**\n\n```javascript\nfunction foo() {\n  console.log(\"foo\");\n}\n\nfunction bar() {\n  console.log(\"bar\");\n}\n\n// 타이머 함수 setTimeout은 일정 시간이 경과한 이후에 콜백 함수 foo를 호출한다.\n// 타이머 함수 setTimeout은 bar 함수를 블로킹하지 않는다.\nsetTimeout(foo, 3 * 1000);\nbar();\n// bar 호출 -> (3초 경과 후) foo 호출\n```\n\n`setTimeout` 함수는 위의 `sleep` 함수와 유사하게 일정 시간이 경과한 이후에 콜백 함수를 호출하지만 `setTimeout` 함수 이후의 태스크를 블로킹하지 않고 곧바로 실행한다. 이처럼 `실행 중인 태스크가 종료되지 않은 상태라 해도 다음 태스크를 곧바로 실행하는 방식은 비동기(Asynchronous)처리`라고 한다.\n\n&nbsp;\n\n![](img6.png)\n\n동기 처리 방식은 태스크를 순서대로 하나씩 처리하므로 실행 순서가 보장된다는 장점이 있지만, 앞선 태스크가 종료할 때까지 이후 태스크들이 블로킹 되어 처리 시간이 늘어날 수 있다는 단점이 있다. 비동기 처리 방식은 현재 실행 중인 태스크가 종료되지 않은 상태라 해도 다음 태스크를 곧바로 실행하므로 블로킹이 발생하지 않고 처리 시간이 단축된다는 장점이 있지만, 태스크의 실행 순서가 보장되지 않는다는 단점이 있다.\n\n&nbsp;\n\n&nbsp;\n\n## **이벤트 루프와 태스크 큐**\n\n### **싱글스레드인 자바스크립트의 비동기가 가능한 이유**\n\n자바스크립트의 특징 중 하나는 싱글 스레드로 동작한다는 것인데, 싱글 스레드는 한 번에 하나의 태스크만 처리할 수 있다는 것을 의미한다. 하지만 브라우저가 동작하는 것을 살펴보면 많은 태스크가 동시에 처리되는 것처럼 느껴진다. `자바스크립트의 동시성을 지원하는 것이 바로 이벤트 루프`이다. `이벤트 루프는 브라우저에 내장되어 있는 기능` 중 하나다.\n\n![](img4.png)\n\n대부분의 자바스크립트 엔진은 크게 2개의 영역으로 구분할 수 있다.\n\n### **콜 스택**\n\n소스코드 평가 과정에서 생성된 실행 컨텍스트가 추가되고 제거되는 스택 자료구조인 실행 컨텍스트 스택이 바로 콜 스택이다. 함수를 호출하면 함수 실행 컨텍스트가 순차적으로 콜 스택에 푸시되어 순차적으로 실행된다.\n\n### **힙**\n\n힙은 객체가 저장되는 메모리 공간으로, 콜 스택의 요소인 실행 컨텍스트는 힙에 저장된 객체를 참조한다. 메모리에 값을 저장하려면 먼저 값을 저장할 메모리 공간의 크기를 결정해야 한다. 객체는 원시 값과는 달리 크기가 정해져 있지 않으므로 할당해야 할 메모리 공간의 크기를 런타임에 결정(동적 할당)해야 한다. 따라서 객체가 저장되는 메모리 공간인 힙은 구조화되어 있지 않다는 특징이 있다.\n\n&nbsp;\n\n&nbsp;\n\n자바스크립트 엔진은 단순히 태스크가 요청되면 콜 스택을 통해 요청된 작업을 순차적으로 실행할 뿐이다. 비동기 처리에서 소스코드의 평가와 실행을 제외한 모든 처리는 자바스크립트 엔진을 구동하는 환경인 브라우저 또는 Node.js 가 담당한다. 이를 위해 브라우저 환경은 태스크 큐와 이벤트 루프를 제공한다.\n\n### **태스크 큐(task queue / event queue / callback queue)**\n\n`setTimeout` 이나 `setInterval` 같은 비동기 함수의 콜백 함수 또는 이벤트 핸들러가 일시적으로 보관되는 영역이다.\n\n### **이벤트 루프**\n\n콜 스택에 현재 진행 중인 실행 컨텍스트가 있는지, 태스크 큐에 대기 중인 함수(콜백 함수, 이벤트 핸들러 등)가 있는지 반복해서 확인한다. 만약 콜 스택이 비어있고 태스크 큐에 대기 중인 함수가 있다면 `이벤트 루프는 순차적으로(FIFO) 태스크 큐에 대기 중인 함수를 콜 스택으로 이동`시킨다. 이때 콜 스택으로 이동한 함수는 실행된다. 즉, 태스크 큐에 임시 보관된 함수들은 비동기 처리 방식으로 동작한다.\n\n```javascript\nfunction foo() {\n  console.log(\"foo\");\n}\nfunction bar() {\n  console.log(\"bar\");\n}\n\nsetTimeout(foo, 0); // 0초(실제는 4ms) 후에 foo 함수가 호출된다.\nbar();\n```\n\n위 예제의 실행 순서를 보면\n\n1. 전역 코드가 평가되어 전역 실행 컨텍스트가 생성되고 콜 스택에 푸시된다.\n\n2. 전역 코드가 실행되기 시작하여 `setTimeout` 함수가 호출된다. 이때 `setTimeout` 함수의 함수 실행 컨텍스트가 생성되고 콜 스택에 푸시되어 현재 실행 중인 실행 컨텍스트가 된다.\n\n3. `setTimeout` 함수가 실행되면 콜백 함수를 호출 스케줄링하고 종료되어 콜 스택에서 팝된다.\n\n   -> 이때 타이머를 설정하고 타이머가 만료되면 콜백 함수를 태스크 큐에 푸시하는 것(호출 스케줄링)은 브라우저의 역할이다.\n\n4. - 브라우저: 타이머를 설정하고 타이머의 만료를 기다린다. 이후 타이머가 만료되면 콜백 함수 `foo` 가 태스크 큐에 푸시된다.\n\n   - 자바스크립트 엔진: `bar` 함수가 호출되어 `bar` 함수의 함수 실행 컨텍스트가 생성되고 콜 스택에 푸시되어 현재 실행 중인 실행 컨텍스트가 된다. 이후 `bar` 함수가 종료되어 콜 스택에서 팝된다.\n\n5. 전역 코드 실행이 종료되고 전역 실행 컨텍스트가 콜 스택에서 팝된다. 이로서 콜 스택에는 아무런 실행 컨텍스트도 존재하지 않게 된다.\n\n6. 이벤트 루프에 의해 콜 스택이 비어 있음이 감지되고 태스크 큐에서 대기 중인 콜백 함수 `foo` 가 이벤트 루프에 의해 콜 스택에 푸시된다. 즉, 콜백 함수 `foo` 의 함수 실행 컨텍스트가 생성되고 콜 스택에 푸시되어 현재 실행 중인 실행 컨텍스트가 된다. 이후 `foo` 함수가 종료되어 콜 스택에서 팝된다.\n"},{"excerpt":"개인 코드 스타일을 드러낼 작은 프로젝트를 진행하면서, 기존에 사용했던 Sequelize 대신 Typeorm 을 적용해 보고 있다. 아직 시작한 지 얼마 되지 않아서 적응 중이고, 딥한 레벨의 로직을 구현하지 않았기 때문에 아주 큰 차이점을 느끼진 못했지만, ORM 에서 레이어 분리를 위해 자주 사용하는 repository 를 구현할 때의 차이점을 기록해…","fields":{"slug":"/custom-repository/"},"frontmatter":{"date":"June 04, 2024","title":"Custom repository 적용하기 (feat. Sequelize, TypeORM)","tags":["조각글"]},"rawMarkdownBody":"\n개인 코드 스타일을 드러낼 작은 프로젝트를 진행하면서, 기존에 사용했던 [Sequelize](https://sequelize.org) 대신 [Typeorm](https://typeorm.io) 을 적용해 보고 있다.\n\n아직 시작한 지 얼마 되지 않아서 적응 중이고, 딥한 레벨의 로직을 구현하지 않았기 때문에 아주 큰 차이점을 느끼진 못했지만, ORM 에서 레이어 분리를 위해 자주 사용하는 repository 를 구현할 때의 차이점을 기록해 보는 포스팅이다.\n\n## **Sequelize custom repository**\n\n```typescript\n// UserRepository.ts\n\n@Injectable()\nexport class UserRepository {\n  constructor(@InjectModel(User) private readonly repository: typeof User) {}\n\n  async findUserById(id: number): Promise<User> {\n    return this.repository.findByPk(id);\n  }\n}\n```\n\n- sequelize 에서는 `@Injectable()` 데코레이터를 통해 `UserRepository` 클래스를 NestJS 컨테이너에 등록하고 관리한다.\n- 클래스의 생성자에서 `@InjectModel(User)` 데코레이터를 사용하여 User 모델을 주입받는다.\n\n&nbsp;\n\n```typescript\n// UserModel.ts\n\n@Table({ tableName: 'user' })\nexport class User extends Model\n```\n\n- 이때 `@Table` 데코레이터를 통해 `User` 테이블과 `User` 모델이 맵핑되기 때문에 User 모델을 주입받을 수 있다.\n\n&nbsp;\n\n```typescript\n// UserModule.ts\n\n@Module({\n  imports: [SequelizeModule.forFeature([User])],\n  providers: [UserRepository],\n})\nexport class UseRepositoryModule {}\n```\n\n- `SequelizeModule.forFeature` 를 통해 repository 를 NestJS 모듈 DI 에 등록하면 다른 서비스나 모듈에서도 해당 repository 를 주입받아 사용할 수 있다.\n\n&nbsp;\n\n&nbsp;\n\n## **TypeORM custom repository**\n\n```typescript\n// UserRepository.ts\n\n@Injectable()\nexport class UserRepository extends Repository<User> {\n  constructor(private dataSource: DataSource) {\n    super(User, dataSource.createEntityManager());\n  }\n\n  async findOneById(id: number): Promise<User> {\n    return this.findOneBy({ id });\n  }\n}\n```\n\n해당 방식은 [여기](https://gist.github.com/anchan828/9e569f076e7bc18daf21c652f7c3d012?permalink_comment_id=4319458#gistcomment-4319458)에서 찾은 방식인데, 본문에 소개된 `@CustomRepository` 방식보다 더 직관적이고 깔끔해서 이 방식으로 적용했다.\n\n- `Repository` 클래스를 상속받는 자식 클래스에서 `DataSource` 를 주입 받고, 생성자를 호출하면서 `UserRepository` 를 생성한다.\n\n- TypeORM 은 repository 클래스를 생성 시 `EntityTarget` 과 `EntityManager` 를 생성하는데, `EntityTarget` 은 클래스가 다룰 타겟 `entity` 이고, `EntityManager` 는 데이터베이스 통신 작업을 수행하는 컴포넌트이다.\n\n- `DataSource` 는 데이터베이스 연결 및 `EntityManager` 생성을 관리하기 때문에 `DataSource` 를 주입받아서 `Custom Repository` 와 `EntityManager` 를 생성하고, 해당 `EntityManager` 를 통해 데이터베이스 작업을 수행하는 방식으로 동작한다.\n\n&nbsp;\n\n```typescript\n// UserModule.ts\n\n@Module({\n  imports: [TypeOrmModule.forFeature([User])],\n  providers: [UserRepository],\n})\nexport class UserModule {}\n```\n\n- `TypeOrmModule.forFeature` 를 통해 repository 를 NestJS 모듈 DI 에 등록하면 다른 서비스나 모듈에서도 해당 repository 를 주입받아 사용할 수 있다.\n"},{"excerpt":"최소비용 신장 트리 (MST, Minimum Spanning Tree) 무방향 (양수) 가중치 그래프면서 엣지들에 의해 그래프의 모든 정점들이 서로 연결되면서 가중치의 합이 최소가 되는 트리  사이클(cycle) 이 없는 연결된(connected) 무방향 그래프를 트리라고 한다. 우리가 보통 말하는 트리(ex 이진트리) 는 rooted tree 라고 부른…","fields":{"slug":"/minimum-spanning-tree/"},"frontmatter":{"date":"June 01, 2024","title":"최소비용 신장 트리 (Minimum Spanning Tree)","tags":["Data-structure"]},"rawMarkdownBody":"\n## **최소비용 신장 트리 (MST, Minimum Spanning Tree)**\n\n무방향 (양수) 가중치 그래프면서 엣지들에 의해 그래프의 모든 정점들이 서로 연결되면서 가중치의 합이 최소가 되는 트리\n\n![](img1.png)\n\n- 사이클(cycle) 이 없는 연결된(connected) 무방향 그래프를 트리라고 한다.\n- 우리가 보통 말하는 트리(ex 이진트리) 는 rooted tree 라고 부른다.\n- 가중치의 합이 최소이기 위해서는 싸이클이 없어야 하므로 MST 문제의 답은 항상 트리가 된다.\n- 노드가 n 개인 트리는 항상 n-1 개의 엣지를 가진다.\n- MST 는 유일하지 않다.\n\n## **Generic MST 알고리즘**\n\nMST 를 찾을 수 있는 두 가지 알고리즘 (Kruskal’s Algorithm, Prim’s Algorithm) 의 공통된 근본 알고리즘으로 **어떤 MST 의 부분집합 A 에 대해서 A 에 다른 엣지 (u, v) 를 추가해도 어떤 MST 의 부분집합이 될 경우 엣지 (u, v) 는 A 에 대해서 안전하다(safe)** 고 한다.\n\n![](img2.png)\n\n```graphql\n1. 처음에는 A 가 공집합이다.\n2. A 가 MST 가 되기 전까지 (엣지의 개수가 n-1 개가 되기 전까지)\n3. 안전한 엣지 (u, v) 를 찾아서\n4. A 와 합친다.\n5. 엣지의 개수가 n-1 개에 도달하면 A 를 반환한다.\n```\n\n&nbsp;\n\n### **안전한 엣지 찾기**\n\n![](img3.png)\n\n- 그래프의 정점들을 두 개의 집합 S 와 V-S 로 분할한 것을 **컷(cut)**(S, S-V) 라고 부른다.\n- 엣지 (u, v) 에 대해서 u 는 S 에 속하고 v 는 S-V 에 속할 때 엣지 (u, v) 는 컷(S, S-V)을 **cross 한다**고 한다.\n- 엣지들의 부분집합 A 에 속한 어떤 엣지도 컷(S, S-V) 를 cross 하지 않을 때 A 는 컷(S, S-V) 을 **존중한다(respect)**고 한다.\n- 만약 어떤 엣지의 값이 cut 을 가로지르는 엣지 중에 가장 작다면 그 엣지를 **가벼운 엣지(light edge)** 라고 부른다.\n\n&nbsp;\n\n### **증명**\n\nA 가 어떤 MST 의 부분집합이고, (S, V-S) 는 A 를 존중하는 컷이라고 할 때, 이 컷을 cross 하는 엣지들 중 가장 가중치가 작은 엣지 (u, v) 는 A 에 대해서 안전하다.\n\n![](img4.png)\n\n- A 가 어떤 MST 의 부분집합이므로 A 를 포함하는 MST 가 존재하며, MST 는 모든 정점이 연결되어 있어야 하므로 S 와 V-S 에 있는 A 의 엣지들을 잇는 엣지 e’ 가 존재한다고 가정한다.\n- 가중치가 가장 작은 엣지 (u,v) 를 e 라고 하면 w(e’) ≥ w(e) 이다.\n- 엣지 e’ 대신 e 를 A 의 일부로 삼아도 가중치의 합은 동일하거나 감소하게 된다.\n- MST 는 가중치의 합이 최소이므로 엣지 e 는 A 에 대해 안전하다.\n\n&nbsp;\n\n&nbsp;\n\n## **Kruskal 의 알고리즘**\n\n- 엣지들은 가중치의 오름차순으로 정렬한다.\n- 엣지들을 그 순서대로 하나씩 선택해 나간다. 단, 이미 선택된 엣지들과 사이클(cycle)을 형성하면 선택하지 않는다.\n- n-1 개의 엣지가 선택되면 종료한다.\n\n![](img5.png)\n\n### **증명**\n\n![](img6.png)\n\n- Kruskal 의 알고리즘의 임의의 한 단계를 생각해본다.\n- A 를 현재까지 알고리즘이 선택한 엣지의 집합이라고 하고, A 를 포함하는 MST 가 존재한다고 가정한다.\n- (S, V-S) 는 A 를 존중하는 컷이라고 할 때, 이 컷을 cross 하는 엣지들 중 가장 가중치가 작은 엣지 (u, v) 는 A 에 대해서 안전하다. → **Generic MST 알고리즘**\n- (S, V-S)를 cross 하는 엣지들 중 가장 가중치가 작은 엣지 (u, v) 가 Kruskal 의 알고리즘이 선택하는 엣지이므로 해당 엣지가 A 와 합쳐져도 A 는 여전히 MST 이다.\n\n&nbsp;\n\n### **사이클 검사**\n\n- 초기 상태 : 선택된 엣지 없음 (A 는 공집합)\n- 각각의 연결요소를 하나의 집합으로 표현한다.\n- 사이클은 이미 연결된 노드를 다시 연결할 때 생긴다.\n\n![](img7.png)\n\n![](img8.png)\n\n![](img9.png)\n\n![](img10.png)\n\n![](img11.png)\n\n![](img12.png)\n\n```graphql\n1. 처음에는 A 가 공집합이다.\n2. 그래프의 모든 정점 v 에 대하여\n3. 각각의 노드들을 유일한 원소로 가지는 집합을 만든다. (초기화)\n4. 엣지들을 가중치의 오름차순으로 정렬한다.\n5. 정렬된 엣지들을 가중치의 오름차순으로 하나씩 확인한다.\n6. 하나의 엣지에 있는 노드들이 각각 다른 집합에 속할 때\n7. A 에 해당 엣지를 추가한다.\n8. 각 노드가 속한 집합을 하나로 합친다.\n9. 엣지의 개수가 n-1 개에 도달하면 A 를 반환한다.\n```\n\n&nbsp;\n\n## **서로소 집합 (Disjoint Set)**\n\n![](img13.png)\n\n- 각 집합을 하나의 트리로 표현한다 → {1, 5}, {2, 4, 7, 10}, {3, 6, 8, 9}\n- 집합의 각 원소들이 트리의 노드가 되는데, 루트 여부나 부모 자식 관계도 상관이 없다.\n- 아래 → 위로 진행하는 상향식 트리이기 때문에 트리의 각 노드는 자식 노드가 아닌 부모 노드의 주소를 가진다.\n- 모든 트리를 하나의 배열로 표현한다.\n\n&nbsp;\n\n### **Find-Set(v)**\n\n자신이 속한 트리의 루트를 찾는다.\n\n![](img14.png)\n\n```graphql\n1. x 가 x 의 부모가 아니면\n2. x 의 부모가 속한 트리를 다시 검사한다.\n3. x 의 부모가 x 라면(x 가 트리의 루트라는 의미) x 의 부모를 반환한다.\n```\n\n&nbsp;\n\n### **Union-Set(u, v)**\n\n한 트리의 루트를 다른 트리의 루트의 자식 노드로 만든다.\n\n![](img15.png)\n\n![](img16.png)\n\n```graphql\n1. u 가 속한 트리의 루트 x 를 찾는다.\n2. v 가 속한 트리의 루트 y 를 찾는다.\n3. y 를 x 의 부모로 한다.\n```\n\n&nbsp;\n\n### **Weighted Union**\n\n두 집합을 합칠 때 트리의 높이를 낮게 유지해야 하므로 작은 트리의 루트를 큰 트리의 루트의 자식으로 만든다.\n\n![](img17.png)\n\n### **Path Compression (경로 압축)**\n\n특정 노드에서 트리의 루트까지 탐색할 때, 지나간 노드들을 투트 노드의 자식으로 붙여서 루트의 높이를 줄인다.\n\n![](img25.png)\n\n![](img19.png)\n\n## **Prim 의 알고리즘**\n\n- 임의의 노드를 출발 노드로 선택한다.\n- 출발 노드를 포함하는 트리를 점점 키워간다.\n- 매 단계에서 이미 트리에 포함된 노드와 포함되지 않은 노드를 연결하는 엣지들 중 가장 가중치가 작은 엣지를 선택한다.\n\n![](img20.png)\n\n### **증명**\n\n![](img21.png)\n\n- Prim 의 알고리즘의 임의의 한 단계를 생각해본다.\n- A 를 현재까지 알고리즘이 선택한 엣지의 집합이라고 하고, A 를 포함하는 MST 가 존재한다고 가정한다.\n- (S, V-S) 는 A 를 존중하는 컷이라고 할 때, 이 컷을 cross 하는 엣지들 중 가장 가중치가 작은 엣지 (u, v) 는 A 에 대해서 안전하다. → **Generic MST 알고리즘**\n- (S, V-S)를 cross 하는 엣지들 중 가장 가중치가 작은 엣지 (u, v) 가 Prim 의 알고리즘이 선택하는 엣지이므로 해당 엣지가 A 와 합쳐져도 A 는 여전히 MST 이다.\n\n&nbsp;\n\n### **가중치가 최소인 엣지 찾기**\n\n- VA : 이미 트리에 포함된 노드들\n- VA 에 아직 속하지 않은 각 노드 v 에 대하여 key 와 π 의 값을 유지한다.\n  - key(v) : 이미 VA 에 속한 노드와 자신을 연결하는 엣지들 중 가중치가 최소인 엣지 (u, v) 의 가중치\n  - π(v) : 엣지 (u, v) 의 끝점 u\n\n![](img22.png)\n\n- 가중치가 최소인 엣지 대신 key 값이 최소인 노드를 찾는다.\n- key 값이 최소인 노드 f 를 찾고, 엣지 (f, π(f)) 를 선택한다.\n\n![](img23.png)\n\n- 추가한 노드의 인접한 노드들 중 key 값이 더 작아지는 경우 갱신한다 → 노드 ~~d~~, g, e 의 값을 갱신한다.\n- 최소 우선순위 큐를 사용한다 → 노드들을 저장한 후, key 값이 최소인 노드를 삭제하고 반환한다.\n\n![](img24.png)\n\n```graphql\n1. 그래프의 모든 정점 v 에 대하여\n2. key 값을 무한대로 둔다.\n3. π 는 null 로 둔다. (초기화)\n4. 출발점 r 의 key 값을 0로 둔다.\n5. 모든 노드를 우선 순위 Queue 에 넣는다.\n6. Queue 가 비어있지 않은 동안에\n7. Queue 에서 최소값 u 를 찾는다.\n8. Queue 에서 u 의 인접한 노드 v 에 대하여\n9. v 가 아직 VA 에 속해있지 않으면서 u 의 키 값보다 엣지(u, v) 의 가중치가 작다면\n10. v 의 π 를 u 로 한다.\n11. v 의 key 를 엣지(u, v) 의 가중치로 한다.\n```\n"},{"excerpt":"why 몇 년 전부터 계속 블로그를 옮기고 싶었는데, 몇 가지 이유가 있었다. 기존에 사용하던 티스토리는 확장성에 제약이 많았고, 마크다운 형식이 편한 나에게 묘하게 호환되지 않는 티스토리 마크다운 방식이 불편했다. 나는 단순한 걸 좋아하고 뭐든지 파편화되어 있는 걸 싫어하는데, 공부할 때는 접근성이 편한 노션으로 공부를 하고, 코드를 작성할 때는 ide…","fields":{"slug":"/blog-migration/"},"frontmatter":{"date":"May 31, 2024","title":"블로그 옮기기","tags":["조각글"]},"rawMarkdownBody":"\n## **why**\n\n몇 년 전부터 계속 블로그를 옮기고 싶었는데, 몇 가지 이유가 있었다.\n\n1. 기존에 사용하던 티스토리는 확장성에 제약이 많았고, 마크다운 형식이 편한 나에게 묘하게 호환되지 않는 티스토리 마크다운 방식이 불편했다.\n2. 나는 단순한 걸 좋아하고 뭐든지 파편화되어 있는 걸 싫어하는데, 공부할 때는 접근성이 편한 노션으로 공부를 하고, 코드를 작성할 때는 ide 를 사용하고, 남에게 보여줄 만한 글을 작성할 때는 티스토리를 사용하는 게 불편했다.\n3. 그런 이유로 공부할 때 가장 많이 사용하는 노션을 블로그로 고려해 봤고, 그동안 공부한 내용들이 많이 쌓여 있었기 때문에 노션을 블로그로 연동한다면 여러모로 간편할 것 같았다. 그렇지만.. 노션의 가장 큰 단점인 `남이 보기 불편한 레이아웃` 때문에 노션을 블로그로 사용하는 건 포기했다.\n\n그래서 확장성을 갖추고, ide 에서 바로 내용을 정리해서 작성할 수 있고, 작성 방식에도 자유도가 높은 블로그를 직접 만들기로 했다.\n&nbsp;\n\n&nbsp;\n\n## **Jekyll vs Gatsby**\n\n좀 더 편해지자고 블로그를 옮기는 것이기에 많은 사람들이 이용하는 편한 방식의 블로그를 만들기로 했고, 가장 많이 사용하는 Jekyll 과 Gatsby 두 가지 방식이 추려졌다.\n\nJekyll 과 Gatsby 둘 다 보편적으로 많이 사용되는데, 둘 중에 하나를 선택하는 건 어렵지 않았다. 나는 루비를 잘 모르기 때문에 나에게 익숙한 Node.js 기반의 Gatsby 를 선택했고, 아주 좋은 선택이었다. 여러 시행착오가 있었지만 생각보다 수월하게 작업하여 배포까지 3시간 정도밖에 소요되지 않았다.\n&nbsp;\n\n&nbsp;\n\n## **오픈소스 활용**\n\n나는 프론트 지식이 거의 없고, 특히나 리액트에 대해서는 아는 게 전혀 없었기 때문에 만들어진 블로그 템플릿을 사용해서 블로그를 만들었다.\n내가 사용한 템플릿은 [devHudi 님의 템플릿](https://github.com/devHudi/gatsby-starter-hoodie/tree/main) 인데, 리드미에 서버 띄우는 방법부터 프로젝트 설정 방식까지 너무나도 친절하게 적혀 있어서 빠르고 간편하게 작업할 수 있었다. 디자인도 깔끔하고 군더더기 없고, 포스팅 목차 기능이나 태그 기능처럼 내가 필수적으로 원했던 기능도 포함되어 있어서 좋았다. 이 글을 보실 일은 없을 것 같지만.. 템플릿을 공유해 주신 devHudi 님께 감사의 말씀을 드리고 싶다.\n&nbsp;\n\n&nbsp;\n\n## **and**\n\n오랫동안 생각했던 과업을 달성했으니 이전 블로그에 있던 글들을 조금씩 옮겨오고, 노션에 적은 공부 글들도 옮겨올 생각이다.\n그리고 블로그를 배포하는 과정에서 종속성 문제로 좀 고생을 해서.. 그 기록도 추후에 남겨 봐야겠다.\n"},{"excerpt":"이번에 블로그를 옮기면서 gatsby 를 처음 사용해 봤는데, 큰 문제는 아니었어도 배포 과정에서 겪은 종속성 문제를 기록해보면 좋을 것 같단 생각이 들었다. 문제는 로컬 환경에서 잘 실행되는걸 확인한 프로젝트를 GitHub 에 푸시한 후, 정적 사이트를 호스팅할 수 있는 GitHub Pages 로 배포하는 과정에서 발생했다. gh-pages 는 프로젝트…","fields":{"slug":"/gatsby-version-ps/"},"frontmatter":{"date":"May 31, 2024","title":"종속성 문제 해결하기","tags":["조각글"]},"rawMarkdownBody":"\n이번에 블로그를 옮기면서 gatsby 를 처음 사용해 봤는데, 큰 문제는 아니었어도 배포 과정에서 겪은 종속성 문제를 기록해보면 좋을 것 같단 생각이 들었다.\n\n문제는 로컬 환경에서 잘 실행되는걸 확인한 프로젝트를 GitHub 에 푸시한 후, 정적 사이트를 호스팅할 수 있는 GitHub Pages 로 배포하는 과정에서 발생했다. [gh-pages](https://github.com/tschaub/gh-pages) 는 프로젝트를 GitHub Pages 에 쉽게 배포할 수 있도록 도와주는 패키지인데, 아주 예전에 팀 프로젝트를 진행할 때 사용해 본 경험이 있어서 또 해당 패키지를 사용하기로 했다.\n&nbsp;\n\n&nbsp;\n\n&nbsp;\n\n### **문제1: 프로젝트 Node version**\n\n![억장 와르르](img1.png)\n\n설치 시도를 하자마자 종속성 문제 에러가 발생했다. 내 로컬 환경 노드 버전이 좀 높기도 했고(20.버전이었다.), 보통 노드 버전 때문에 종속성 문제가 많이 발생하기 때문에 빠르게 레포 이슈를 검색했다.\n&nbsp;\n\n&nbsp;\n\n![](img2.png)\n\n예상처럼 노드 버전을 확인했고, 바로 14 버전으로 다운그레이드 시켜주었다.\n&nbsp;\n\n&nbsp;\n\n&nbsp;\n\n&nbsp;\n\n### **문제2: 패키지 Node version**\n\n다시 설치를 시도했는데, 이번에는 `ph-pages` 의 노드 버전이 안 맞는다는 에러가 발생했다. 갑자기 현업 때의 고통이 밀려왔다..\n&nbsp;\n\n&nbsp;\n\n![](img5.png)\n\n확인해 보니 노드 14 버전은 쓸 수 없다고 해서 고민을 했다. Netlify 같은 다른 배포 도구를 사용할지 다른 패키지를 찾아서 배포할지 고민하다 한번 노드 버전을 올려보기로 했고, 20 아래 버전 LTS 인 노드 18로 업그레이드를 해주었다.\n&nbsp;\n\n&nbsp;\n\n&nbsp;\n\n### **문제3: 패키지 의존성 충돌**\n\n![응 돌아가](img3.png)\n\n프로젝트 권장 노드 버전이 아니기 때문에 에러가 발생했고, 이제는 패키지 버전을 살필 차례였다. `gatsby-remark-katex` 는 `gatsby` 의 특정 버전(^2.0.0) 을 필요로 하는데, 현재 프로젝트에는 호환되지 않는 최신 버전(5.13.6) 의 `gatsby` 가 설치되어 있어서 발생하는 문제로 보였다. 단순히 생각했을 때는 패키지의 버전을 올리면 되지 않나 싶었는데, 뭔가 이유가 있어서 낮은 버전으로 사용되고 있을 것 같단 생각이 들었다.\n분명 같은 문제가 발생한 사람이 있을 것 같아서 또 레포로 달려가서(...) 검색을 해보니,\n&nbsp;\n\n&nbsp;\n\n&nbsp;\n\n![](img4.png)\n\ngatsby 5 마이그레이션 이후 볼드 처리 문제가 있어서 remark 패키지를 다운 그레이드 했다는 PR 기록이 있었다.\n&nbsp;\n\n&nbsp;\n\n&nbsp;\n\n### **요약**\n\n- 노드 버전 포기 -> 원하는 배포 방식 적용 불가능\n- 원하는 배포 방식 적용 -> 패키지 의존성 해결 불가능\n\n인 상황이었는데, 사실 패키지 의존성 문제가 발생해서 구글에 검색을 하면 `--legacy-peer-deps` 라는 특정 명령어로 임시 조치하라는 글들이 꽤나 많았기 때문에 해당 명령어로 해결할까 하는 생각도 들긴 했지만.. 현업에서 임시 조치의 부메랑을 맞아본 적이 있어서 조금 더 좋은 해결 방법을 찾고 싶었다.\n\n그래서 한 번 npm 말고 yarn 으로 설치해 볼까? 하는 생각이 들었고, 정말 놀랍게도 yarn 으로 해결이 되었다. (속도도 훨씬 빠른 건 덤..) 그동안 패키지 매니저 관련 글도 많이 봤고, 얼마 전에 토스 기술 블로그에서 [패키지 매니저 관련 글](https://toss.tech/article/lightning-talks-package-manager)도 봤지만, 실제로 패키지 매니저의 종류에 따라 개발에 차질이 생긴 건 처음이라 굉장히 좋은 경험이었다.\n\n하나 의문인 점은 로컬 환경에서 노드 20.13.1 버전으로 프로젝트를 빌드 할 때는 빌드가 잘 됐었는데, 코드를 푸시하고 다른 패키지 설치 시도를 하자마자 멀쩡히 돌아가던 패키지 에러가 발생한 점이다. 아직도 이유를 모르겠다..\n\n게다가 근본적인 종속성 문제를 해결한 건 아니기 때문에 추후에 gatsby 패키지 관련 이슈를 팔로업하면서 의존성 문제가 발생하지 않는 버전으로 업그레이드하는 방식으로 해결해 볼 생각이다.\n"},{"excerpt":"문제 링크 배열을 입력받아 합으로 0을 만들 수 있는 3개의 요소를 배열로 감싸서 출력하는 문제이다. 가장 처음 든 풀이법은 역시 브루트포스였지만 시간복잡도 때문에 타임아웃이 발생할 것 같아서 다른 방법으로 접근하기로 했고, 2Sum 풀 때처럼 투 포인터 방식으로 풀면 되겠다는 판단이 들었다. 첫번째 풀이  인풋 배열을 정렬시킨 후, 첫 수를 고정시키고 …","fields":{"slug":"/leetcode-3sum/"},"frontmatter":{"date":"May 18, 2024","title":"leetcode 15. 3Sum","tags":["Algorithm"]},"rawMarkdownBody":"\n[문제 링크](https://leetcode.com/problems/3sum/description/)\n\n배열을 입력받아 합으로 0을 만들 수 있는 3개의 요소를 배열로 감싸서 출력하는 문제이다.\n\n가장 처음 든 풀이법은 역시 브루트포스였지만 시간복잡도 때문에 타임아웃이 발생할 것 같아서 다른 방법으로 접근하기로 했고, 2Sum 풀 때처럼 투 포인터 방식으로 풀면 되겠다는 판단이 들었다.\n\n### _**첫번째 풀이**_\n\n![](img1.png)\n\n인풋 배열을 정렬시킨 후, 첫 수를 고정시키고 나머지 두 수를 첫 수의 바로 다음 수와 가장 마지막 수로 고정, 투 포인터 방식으로 단계별로 증감시키는 방식이다.\n\n첫 수를 고정시키고 나머지 수까지의 합을 구하는 방식이기 때문에 첫 수가 중복인 경우는 스킵했고, 수의 합을 0 과 비교해서 포인터를 이동시켰다.\n\n이 풀이의 문제점은 이 \\[-2,0,0,2,2\\] 처럼 포인터를 이동한 결과가 중복되는 경우를 처리하지 못 한다는 점이었다.\n\n&nbsp;\n\n### _**두번째 풀이**_\n\n![](img2.png)\n\n중복 추가되는 경우를 방지하기 위해 세 수의 합이 0인 경우, 포인터를 이동시켜서 동일 값 여부를 확인하는 코드를 추가했다.\n\n&nbsp;\n\n### _**세번째 풀이**_\n\n![](img3.png)\n\n좀 더 들여다보니 꼭 두개의 포인터 모두 이동시킬 필요는 없어서 오른쪽 포인터를 이동시키는 코드는 제거했다.\n"},{"excerpt":"예전부터 만들어야지 생각하면서 계속 미뤄뒀던.. 확장 프로그램을 드디어 만들어서 간략하게 개발 과정을 작성해 보는 포스팅이다. 개발 이유 이 조그만걸 왜 만들었냐면... 2019년부터 몇년간 잘 쓰던 확장 프로그램이 있었는데, 기능이 그렇게 많지 않았지만 나에게 딱 필요한 기능만 있었기에 아주 잘 쓰고 있었다. 그 확장 프로그램의 기능은 프로그램 아이콘을…","fields":{"slug":"/quick-youtube-search/"},"frontmatter":{"date":"April 17, 2024","title":"작고 귀여운 크롬 확장 프로그램 만들기","tags":["조각글"]},"rawMarkdownBody":"\n예전부터 만들어야지 생각하면서 계속 미뤄뒀던.. 확장 프로그램을 드디어 만들어서 간략하게 개발 과정을 작성해 보는 포스팅이다.\n\n## _**개발 이유**_\n\n이 조그만걸 왜 만들었냐면... 2019년부터 몇년간 잘 쓰던 확장 프로그램이 있었는데, 기능이 그렇게 많지 않았지만 나에게 딱 필요한 기능만 있었기에 아주 잘 쓰고 있었다.\n\n그 확장 프로그램의 기능은\n\n1.  프로그램 아이콘을 누르면 검색 팝업이 뜬다.\n2.  그 상태로 아무것도 검색하지 않고 엔터를 누르면 바로 새 탭이 열리며 유튜브 페이지로 이동된다.\n3.  검색창에 검색어를 치면 추천 검색어가 밑에 표시된다.\n4.  엔터를 누르면 유튜브에 해당 검색어를 검색한 결과가 새 탭으로 열리며 유튜브 페이지로 이동된다.\n\n정도로 아주 간단하고 군더더기 없었는데, 몇년간 정말 잘 썼었다. 하지만 그 뒤로 한차례의 대규모 크롬 업데이트를 거친 뒤에 더 이상 그 프로그램을 쓸 수 없게 되어서 다른 비슷한 유튜브 확장 프로그램을 사용했지만, 동일한 기능이 아니었기에 계속 작은 아쉬움이 있었고, 개발을 배운 뒤에는 내가 만들면 좋겠다는 생각을 늘 갖고 있었다.\n\n&nbsp;\n\n## _**개발 과정**_\n\n가장 먼저 [크롬 개발자 페이지](https://developer.chrome.com/docs/extensions?hl=ko&_gl=1*14e8fz3*_up*MQ..*_ga*MTY4MDgxMTk5LjE3MTMyNzAyMzA.*_ga_H1Y3PXZW9Q*MTcxMzI3MDIyOS4xLjAuMTcxMzI3MDIyOS4wLjAuMA.. \"크롬 개발자 페이지\")를 참고했다. 구글 캘린더 API 연동할 때 설명이 너무 불친절해서 조금 헤맸던 기억이 있었기에 긴장했는데, 개발 자체도 어렵지 않아 보였고, 설명도 잘 되어 있었다.\n\n### _**manifest.json**_\n\n노드에 package.json 이 있다면 크롬 확장 프로그램에는 manifest.json 이라는 파일이 필요한데, 기능이 그렇게 많은 프로그램이 아니라서 최소한으로 간단하게 작성했다.\n\n![](img1.png)\n\n이름도 정말 간단하게 Quick Youtube Search로 지었고, 아이콘을 누른 후 팝업창이 뜨면 검색하는 방식으로 동작하기에 연결되는 팝업 파일 이름도 popup.html로 지었다. 공식 문서에 따르면 2 버전은 올해 6월부터 deprecated 될 예정이고, 앞으로의 최신 표준 버전은 3 버전이기에 3 버전으로 적용시켰다.\n\n&nbsp;\n\n### _**popup.html & popup.css**_\n\nhtml 과 css를 정말 오랜만에 다뤄서 힘들었다. html 은 결제 연동 테스트할 때 샘플 페이지 띄우는 작업 때문에 종종 만져보긴 했지만 css는 그동안 사용한 적이 없어서 고생을 많이 했다.. 일부러 디자인이라고 할만한 요소조차 없게 만들었는데도 시간이 오래 걸렸다. 특히 간격 조정하느라 힘들었는데, 예전에 개발 처음 배울 때 padding 이랑 margin 때문에 고생했던 기억이 떠오르기도 했다.\n\n![](img2.png)\n\n![](img3.png)\n\n&nbsp;\n\n### _**popup.js**_\n\n동작 로직이 담겨 있는 파일이다. 내가 넣은 기능은 이전에 내가 잘 쓰던 프로그램의 기능과 유사한데, 아주 간단한 기능을 하나 추가했다.\n\n1.  프로그램 아이콘을 누르면 검색 팝업이 뜬다.\n2.  그 상태로 아무것도 검색하지 않고 엔터를 누르면 바로 새 탭이 열리며 유튜브 페이지로 이동된다.\n3.  엔터를 누르면 유튜브에 해당 검색어를 검색한 결과가 새 탭으로 열리며 유튜브 페이지로 이동된다.\n4.  팝업의 유튜브 아이콘을 누르면 새 탭이 열리며 유튜브 페이지로 이동된다. -> New!\n\n![](img4.png)\n\n이전 프로그램에 있었던 추천 검색어 기능을 넣으려고 찾아보니 유튜브에서 제공하는 API 가 따로 없고, 추천 검색어 결과를 받아서 내가 리스트 형태로 보여주는 방식으로 개발을 해야 했다. 사실 받아서 보여주는 것 자체는 문제가 없는데, 데이터가 보이도록 html&css 조정을 하는 과정이 정말 오래 걸릴 것 같았기에 아쉽지만 이 기능은 일단 포기할 수밖에 없었다. (추후 구현할 생각 매우 있음..)\n\n30줄 안팎의 짧은 코드였기에 js 로 간단하게 구현했지만, 브라우저 객체를 처음 다뤄보는 거였기에 타입 명시를 할 수 없어서 아쉬웠다. 아마 파일이 한 개만 더 있었어도 ts로 구현했을 것이다.\n\n&nbsp;\n\n&nbsp;\n\n### _**시행착오 1**_\n\n객체를 다루며 놓친 부분이 있었는데, 할당 방식이었다.\n\n![](img5.png)\n\n위의 경우는 searchParams 에 set의 반환값인 Null이 할당되므로\n\n![](img6.png)\n\n위의 방식처럼 해야 URLSearchParams 객체가 생성되고 searchParams에 할당된 후에, set 을 통해 값 세팅이 정상적으로 될 수 있었다.\n\n### _**시행착오 2**_\n\njs 코드를 자꾸 리팩토링하면서 만지다 보니 에러가 발생했는데, 코드를 아무리 봐도 뭐가 잘못된 건지 모르겠어서 디버깅 방법이 있나 찾아봤다. 찾아보니 크롬 확장 프로그램 관리페이지에서 오류 디버깅이 가능했고, 보기도 쉽고 편했다.\n\n![](img7.png)\n\n에러를 확인해보니 set 함수에 들어가야 할 매개변수가 string 타입이어야 했기에 생긴 오류였다. 이것 역시 타입 지정 언어였으면 놓치지 않았을 버그여서 아쉬웠지만, 큰 문제는 아니어서 다행이었다.\n\n&nbsp;\n\n&nbsp;\n\n## _**기타 디자인(?) 요소**_\n\n![](img8.png)\n\n내가 만든 확장 프로그램은 기능도 생김새도 아주 간단하지만 내 형편없는 마크업 실력 덕분에 구현에 시간이 꽤 오래 소요되었다. 그래도 내가 직접 만들기에 고를 수 있는 사소한 요소들이 있어서 소소한 즐거움이 되어주었다.\n\n### _**아이콘**_\n\n프로그램 아이콘과 팝업 검색창 아이콘은 같은 모양으로 맞추고 싶었고, 이전에 쓰던 프로그램 아이콘이 다른 확장프로그램 아이콘들과 크기가 달랐기 때문에 전체적으로 통일감을 주기 위해 크기를 맞추고 싶었는데, 팝업 검색창 아이콘과 동일한 디자인의 정방형 아이콘을 찾을 수 없었다. 그래도 최종적으로 선택된 정방형 아이콘도 깔끔하고, 다른 아이콘들과 크기가 비슷해서 통일감이 생겼다.\n\n### _**색**_\n\n원래 유튜브 로고색은 너무 빨갛게 느껴져서 아이콘의 채도를 살짝 낮추었다.\n\n### _**검색창**_\n\n검색창 인풋도 원래는 좀 더 포커스를 주고 싶어서 외곽 볼드 처리를 했었는데, 커서가 움직이는 것도 나름의 포커스고, 기본 형태가 나은 것 같아서 뺐다.\n&nbsp;\n\n&nbsp;\n\n## _**소감**_\n\n이게 뭐라고 아주 뿌듯하고 너무 재밌었다. 오랫동안 해야지 해야지 생각했던 건데 몇시간 만에 만들 수 있었던 거면 진작 할걸 하는 생각도 들었다. 알고리즘 이지 난이도조차 안 되는 로직에 정말 기본적인 마크업으로만 구성된 프로그램이지만 하나부터 열까지 온전히 내 입맛에 맞출 수 있어서 개발 내내 너무 신났다. (간단한 거라서 그렇게 신났을 수도..) 꽤 오랜 기간 동안은 메뉴바의 아이콘만 봐도 뿌듯할 것 같단 생각이 든다.\n\n&nbsp;\n\n&nbsp;\n\n&nbsp;\n\n참조\n\n[Mozilla doc](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/manifest.json)\n\n[Chrome doc](https://developer.chrome.com/docs/extensions?hl=ko&_gl=1*14e8fz3*_up*MQ..*_ga*MTY4MDgxMTk5LjE3MTMyNzAyMzA.*_ga_H1Y3PXZW9Q*MTcxMzI3MDIyOS4xLjAuMTcxMzI3MDIyOS4wLjAuMA..)\n"},{"excerpt":"자바 아키텍처에는 3가지 구성요소가 있다.\n    \n  JDK(Java Development Kit) 자바 개발 키트는 자바 컴파일러, 디버거, 런타임 환경 등 자바 프로그램을 개발하고 실행하는데에 필요한 도구와 라이브러리를 제공한다. JRE(Java Runtime Environment) JVM 과 런타임 라이브러리 등으로 구성된 자바 어플리케이션을 실행…","fields":{"slug":"/understanding-jvm/"},"frontmatter":{"date":"April 15, 2024","title":"JVM 이해하기","tags":["Java"]},"rawMarkdownBody":"\n자바 아키텍처에는 3가지 구성요소가 있다.\n&nbsp;\n\n&nbsp;\n\n![](img1.png)\n&nbsp;\n\n### **JDK(Java Development Kit)**\n\n자바 개발 키트는 자바 컴파일러, 디버거, 런타임 환경 등 자바 프로그램을 개발하고 실행하는데에 필요한 도구와 라이브러리를 제공한다.\n\n### **JRE(Java Runtime Environment)**\n\nJVM 과 런타임 라이브러리 등으로 구성된 자바 어플리케이션을 실행할 환경이다.\n\n### **JVM(Java Virtual Machine)**\n\n**JVM(Java Virtual Machine, 자바 가상 기계)은 컴파일된 바이트 코드 파일을 운영체제에서 실행 가능한 기계어로 번역해서 실행할 수 있게 해주며, JRE(Java Runtime Env.) 의 일부**이다. 각 운영체제의 JVM 은 바이트 코드 파일을 해당 운영체제에서 실행 가능한 기계어로 번역해서 실행하기 때문에 **운영체제의 제약을 받지 않는 프로그램 개발이 가능**하다.\n&nbsp;\n\n&nbsp;\n\n이 중에서 오늘은 JVM 을 이해하는 것이 목적이다.\n&nbsp;\n\n&nbsp;\n\n![](img2.jpeg)\n\nJVM 에는 세가지 구성요소가 있다.\n\n1. 클래스로더 (Class Loader)\n2. 런타임 메모리 영역 (Runtime Data Area)\n3. 실행 엔진 (Execution Engine)\n\n## **클래스로더**\n\n클래스로더는 java.lang 패키지에 있는 추상 클래스로, .java 파일이 컴파일되어 바이트 코드를 포함한 동일한 이름을 가진 .class 파일이 생성되면 클래스로더가 .class 파일을 읽고 상응하는 이진 데이터를 생성해 JVM 내의 메서드 영역으로 동일한 이름의 클래스 파일을 로드한다.\n\n클래스로더는 **로딩(Loading) -> 링킹(Linking) -> 초기화(Initialization)** 의 순서로 작업을 수행한다.\n&nbsp;\n\n&nbsp;\n\n![](img3.png)\n\n### **로딩**\n\n클래스로더에는 몇가지 종류가 있으며 계층적으로 구성되어 있다.\n\n- 부트스트랩 클래스로더: **가장 먼저 실행되는 루트 클래스로더**로, $JAVA HOME/jre/lib directory 에서 표준 자바 패키지를 가져온다.\n- 익스텐션 클래스로더: 두번째로 실행되는 클래스로더로, 부트스트랩 클래스로더의 자식이자 어플리케이션 클래스로더의 부모이다. $JAVA_HOME/jre/lib/ext directory 에서 표준 자바 라이브러리를 가져온다.\n- 어플리케이션 클래스로더: 마지막으로 실행되는 클래스로더로, 익스텐션 클래스로더의 자식이다. 자바 어플리케이션 파일을 가져와서 실행한다.\n\n계층적 구조에 의해 클래스로더는 부모 클래스로더로부터 클래스를 로드하고 찾지 못할 경우 자식 클래스로더에게 로드를 위임하는 방식으로 동작한다. 이러한 클래스로더의 동작 방식은 **클래스의 중복 로딩을 방지하고 클래스 간의 의존성을 관리**하는 데에 도움이 된다.\n\n### **링킹**\n\n로딩 이후 클래스로더는 파일을 링킹한다. 이 과정에는 클래스로더가 파일을 검증, 준비, 해결하는 단계가 포함되어 있다.\n\n- 검증(verification): ByteCodeVerifier 라는 컴포넌트가 로딩된 .class 파일이 검증된 컴파일러에 의해 컴파일된건지, 구조가 유효한지 등을 검증한다. 검증이 실패하면 런타임 에러가 발생한다.\n- 준비(preparation): 만약 클래스에 인스턴스 요소나 정적 변수가 있다면 기본값을 할당한다.\n- 해결(resolution): 자바 클래스는 다른 클래스에 대한 참조를 포함할 수 있는데, 이러한 참조는 심볼릭 링크로 표현된다. 해결 과정에서 클래스로더는 심볼릭 링크를 직접적 링크로 대체한다.\n\n### **초기화**\n\n초기화 단계에서는 정적 변수를 초기화한다.\n&nbsp;\n\n&nbsp;\n\n---\n\n## **런타임 데이터 영역 (Runtime Data Area)**\n\n런타임 데이터 영역은 JVM 이 실행되는 동안 프로그램이 사용하는 데이터를 저장하는 메모리 영역으로,\n\n- 메서드 영역 (Method Area)\n- 힙 영역 (Heap Area)\n- 스택 영역 (Stack Area)\n- PC 레지스터 (Program Counter Register)\n- 네이티브 메서드 스택 (Native Method Stack) 의 다섯가지 영역으로 이루어져 있다.\n  &nbsp;\n\n  &nbsp;\n\n![](img4.jpeg)\n\n&nbsp;\n\n### **메서드 영역 (Method Area)**\n\n메서드, 필드, 상수 풀, 메타데이터 등의 클래스 정보를 저장하며, 모든 스레드가 공유하는 영역이다.\n\n런타임 상수 풀(Runtime Constant Pool) 이라는 자바 클래스 파일의 구성 요소가 존재하는데, 클래스 파일에 포함된 상수 풀(Constant Pool)의 런타임 버전이다. 즉, 클래스 파일에 정의된 상수들의 런타임 시점에서의 표현을 담고 있다. 자바 컴파일러가 소스 코드를 컴파일하여 클래스 파일을 생성할 때, 상수 풀은 클래스 파일에 상수 값들을 저장하고, 필요한 경우 런타임 중에 상수들을 참조하고 사용할 수 있도록 한다. 이를 통해 자바 프로그램은 동적으로 상수들을 참조하고 변경할 수 있다.\n&nbsp;\n\n&nbsp;\n\n### **힙 영역 (Heap Area)**\n\n![](img5.png)\n\n객체 인스턴스가 생성되는 영역으로, 동적으로 할당된 메모리를 저장한다. GC(Garbage Collection) 의 대상이 되는 메모리 영역으로, 더 이상 사용되지 않는 객체의 메모리를 회수한다. 힙 영역은 모든 스레드가 공유한다.\n\n- Young gen: 새롭게 생성된 클래스 인스턴스들이 저장된다.\n  - Eden: 새롭게 생성된 클래스 인스턴스들이 저장되는 곳으로, Eden 영역이 가득 차면, Minor GC(Garbage Collection) 가 발생하여 Eden 영역에 있는 살아있는 객체들을 체크하고, 살아남은 객체들은 Survivor 영역으로 이동된다. 이후 Eden 영역은 비워진다.\n  - Survivor: 이 영역에서 살아남은 객체들은 Old Generation 으로 이동될 수 있다.\n- Old gen: Young Gen 에서 일정 주기마다 살아남은 객체들이 이동하는 영역이다.\n\n  - 상대적으로 큰 메모리 공간을 가지고 있으며, 오랜 시간 동안 살아남은 객체들이 저장된다.\n  - Old Generation에 있는 객체들은 GC가 발생할 때마다 검사되며, 더 이상 참조되지 않는 객체들은 메모리에서 해제된다.\n\n&nbsp;\n\n### **스택 영역 (Stack Area)**\n\n메서드가 호출되면 새로운 스택 프레임이 생성되는데, 이 스택 프레임이 스택 영역에 저장된다. 메서드의 실행이 종료되거나 에러가 발생하면 스택에서 해당 프레임이 제거된다. 스택 영역은 각 스레드마다 하나씩 존재하며 스레드가 시작될 때 할당된다.\n\n### **PC 레지스터 (Program Counter Register)**\n\n현재 실행 중인 JVM 명령어의 주소를 저장한다. 각 스레드마다 별도로 할당되며, 스레드가 실행될 때마다 초기화된다.\n\n### **네이티브 메서드 스택 (Native Method Stack)**\n\n자바 외부에서 호출되는 네이티브 코드(C 나 C++ 로 작성된 코드) 를 실행하는 데에 사용되는 메모리 영역이다. 스택 영역과 마찬가지로 메서드를 호출할 때마다 해당 스택 프레임이 생성되며, 네이티브 메서드 실행이 종료되면 해당 스택 프레임이 제거된다.\n&nbsp;\n\n&nbsp;\n\n---\n\n## **실행 엔진 (Execution Engine)**\n\n실행 엔진은 JVM 내부에서 Java 바이트 코드를 해석하고 실행하는 역할을 하며\n\n- 인터프리터 (Interpreter)\n- JIT 컴파일러 (Just-In-Time Compiler)\n- GC (Garbage Collection) 으로 구성되어 있다.\n\n![](img6.png)\n\n### **인터프리터 (Interpreter)**\n\nJava 바이트 코드를 한 줄씩 읽어들여서 해당 코드를 직접 실행한다. 이 때문에 코드 실행 속도가 느릴 수 있다.\n\n### **JIT 컴파일러 (Just-In-Time Compiler)**\n\n인터프리터와 함께 사용된다. JIT 컴파일러는 인터프리터가 반복적으로 실행되는 코드를 감지하고, 해당 코드를 네이티브 기계 코드로 컴파일하여 최적화한다. 생성된 네이티브 코드는 캐시에 저장되어 동일한 코드가 실행될 때 재사용된다. 이를 통해 코드 실행 속도를 향상시킬 수 있다.\n\n### **GC (Garbage Collection)**\n\nGC는 JVM 에서 메모리 관리를 위해 사용되는 프로세스이다. GC는 주기적으로 메모리를 검사하여 사용되지 않는 객체를 식별하여 메모리를 해제한다. GC는 JVM 의 일부로 자동으로 실행되며, 개발자가 직접 관여할 필요가 없다.\n&nbsp;\n\n&nbsp;\n\n&nbsp;\n\n&nbsp;\n\n참조\n\nhttps://www.freecodecamp.org/news/jvm-tutorial-java-virtual-machine-architecture-explained-for-beginners/\nhttps://www.geeksforgeeks.org/jvm-works-jvm-architecture/\n"}]}},"pageContext":{}},"staticQueryHashes":[],"slicesMap":{}}