{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"문제 링크 배열을 입력받아 합으로 0을 만들 수 있는 3개의 요소를 배열로 감싸서 출력하는 문제이다. 가장 처음 든 풀이법은 역시 브루트포스였지만 시간복잡도 때문에 타임아웃이 발생할 것 같아서 다른 방법으로 접근하기로 했고, 2Sum 풀 때처럼 투 포인터 방식으로 풀면 되겠다는 판단이 들었다. 첫번째 풀이  인풋 배열을 정렬시킨 후, 첫 수를 고정시키고 …","fields":{"slug":"/leetcode-3sum/"},"frontmatter":{"date":"May 18, 2024","title":"leetcode 15. 3Sum","tags":["Algorithm"]},"rawMarkdownBody":"\n[문제 링크](https://leetcode.com/problems/3sum/description/)\n\n배열을 입력받아 합으로 0을 만들 수 있는 3개의 요소를 배열로 감싸서 출력하는 문제이다.\n\n가장 처음 든 풀이법은 역시 브루트포스였지만 시간복잡도 때문에 타임아웃이 발생할 것 같아서 다른 방법으로 접근하기로 했고, 2Sum 풀 때처럼 투 포인터 방식으로 풀면 되겠다는 판단이 들었다.\n\n### _**첫번째 풀이**_\n\n![](img1.png)\n\n인풋 배열을 정렬시킨 후, 첫 수를 고정시키고 나머지 두 수를 첫 수의 바로 다음 수와 가장 마지막 수로 고정, 투 포인터 방식으로 단계별로 증감시키는 방식이다.\n\n첫 수를 고정시키고 나머지 수까지의 합을 구하는 방식이기 때문에 첫 수가 중복인 경우는 스킵했고, 수의 합을 0 과 비교해서 포인터를 이동시켰다.\n\n이 풀이의 문제점은 이 \\[-2,0,0,2,2\\] 처럼 포인터를 이동한 결과가 중복되는 경우를 처리하지 못 한다는 점이었다.\n\n&nbsp;\n\n### _**두번째 풀이**_\n\n![](img2.png)\n\n중복 추가되는 경우를 방지하기 위해 세 수의 합이 0인 경우, 포인터를 이동시켜서 동일 값 여부를 확인하는 코드를 추가했다.\n\n&nbsp;\n\n### _**세번째 풀이**_\n\n![](img3.png)\n\n좀 더 들여다보니 꼭 두개의 포인터 모두 이동시킬 필요는 없어서 오른쪽 포인터를 이동시키는 코드는 제거했다.\n"},{"excerpt":"예전부터 만들어야지 생각하면서 계속 미뤄뒀던.. 확장 프로그램을 드디어 만들어서 간략하게 개발 과정을 작성해 보는 포스팅이다. 개발 이유 이 조그만걸 왜 만들었냐면... 2019년부터 몇년간 잘 쓰던 확장 프로그램이 있었는데, 기능이 그렇게 많지 않았지만 나에게 딱 필요한 기능만 있었기에 아주 잘 쓰고 있었다. 그 확장 프로그램의 기능은 프로그램 아이콘을…","fields":{"slug":"/quick-youtube-search/"},"frontmatter":{"date":"April 17, 2024","title":"작고 귀여운 크롬 확장 프로그램 만들기","tags":["조각글"]},"rawMarkdownBody":"\n예전부터 만들어야지 생각하면서 계속 미뤄뒀던.. 확장 프로그램을 드디어 만들어서 간략하게 개발 과정을 작성해 보는 포스팅이다.\n\n## _**개발 이유**_\n\n이 조그만걸 왜 만들었냐면... 2019년부터 몇년간 잘 쓰던 확장 프로그램이 있었는데, 기능이 그렇게 많지 않았지만 나에게 딱 필요한 기능만 있었기에 아주 잘 쓰고 있었다.\n\n그 확장 프로그램의 기능은\n\n1.  프로그램 아이콘을 누르면 검색 팝업이 뜬다.\n2.  그 상태로 아무것도 검색하지 않고 엔터를 누르면 바로 새 탭이 열리며 유튜브 페이지로 이동된다.\n3.  검색창에 검색어를 치면 추천 검색어가 밑에 표시된다.\n4.  엔터를 누르면 유튜브에 해당 검색어를 검색한 결과가 새 탭으로 열리며 유튜브 페이지로 이동된다.\n\n정도로 아주 간단하고 군더더기 없었는데, 몇년간 정말 잘 썼었다. 하지만 그 뒤로 한차례의 대규모 크롬 업데이트를 거친 뒤에 더 이상 그 프로그램을 쓸 수 없게 되어서 다른 비슷한 유튜브 확장 프로그램을 사용했지만, 동일한 기능이 아니었기에 계속 작은 아쉬움이 있었고, 개발을 배운 뒤에는 내가 만들면 좋겠다는 생각을 늘 갖고 있었다.\n\n&nbsp;\n\n## _**개발 과정**_\n\n가장 먼저 [크롬 개발자 페이지](https://developer.chrome.com/docs/extensions?hl=ko&_gl=1*14e8fz3*_up*MQ..*_ga*MTY4MDgxMTk5LjE3MTMyNzAyMzA.*_ga_H1Y3PXZW9Q*MTcxMzI3MDIyOS4xLjAuMTcxMzI3MDIyOS4wLjAuMA.. \"크롬 개발자 페이지\")를 참고했다. 구글 캘린더 API 연동할 때 설명이 너무 불친절해서 조금 헤맸던 기억이 있었기에 긴장했는데, 개발 자체도 어렵지 않아 보였고, 설명도 잘 되어 있었다.\n\n### _**manifest.json**_\n\n노드에 package.json 이 있다면 크롬 확장 프로그램에는 manifest.json 이라는 파일이 필요한데, 기능이 그렇게 많은 프로그램이 아니라서 최소한으로 간단하게 작성했다.\n\n![](img1.png)\n\n이름도 정말 간단하게 Quick Youtube Search로 지었고, 아이콘을 누른 후 팝업창이 뜨면 검색하는 방식으로 동작하기에 연결되는 팝업 파일 이름도 popup.html로 지었다. 공식 문서에 따르면 2 버전은 올해 6월부터 deprecated 될 예정이고, 앞으로의 최신 표준 버전은 3 버전이기에 3 버전으로 적용시켰다.\n\n&nbsp;\n\n### _**popup.html & popup.css**_\n\nhtml 과 css를 정말 오랜만에 다뤄서 힘들었다. html 은 결제 연동 테스트할 때 샘플 페이지 띄우는 작업 때문에 종종 만져보긴 했지만 css는 그동안 사용한 적이 없어서 고생을 많이 했다.. 일부러 디자인이라고 할만한 요소조차 없게 만들었는데도 시간이 오래 걸렸다. 특히 간격 조정하느라 힘들었는데, 예전에 개발 처음 배울 때 padding 이랑 margin 때문에 고생했던 기억이 떠오르기도 했다.\n\n![](img2.png)\n\n![](img3.png)\n\n&nbsp;\n\n### _**popup.js**_\n\n동작 로직이 담겨 있는 파일이다. 내가 넣은 기능은 이전에 내가 잘 쓰던 프로그램의 기능과 유사한데, 아주 간단한 기능을 하나 추가했다.\n\n1.  프로그램 아이콘을 누르면 검색 팝업이 뜬다.\n2.  그 상태로 아무것도 검색하지 않고 엔터를 누르면 바로 새 탭이 열리며 유튜브 페이지로 이동된다.\n3.  엔터를 누르면 유튜브에 해당 검색어를 검색한 결과가 새 탭으로 열리며 유튜브 페이지로 이동된다.\n4.  팝업의 유튜브 아이콘을 누르면 새 탭이 열리며 유튜브 페이지로 이동된다. -> New!\n\n![](img4.png)\n\n이전 프로그램에 있었던 추천 검색어 기능을 넣으려고 찾아보니 유튜브에서 제공하는 API 가 따로 없고, 추천 검색어 결과를 받아서 내가 리스트 형태로 보여주는 방식으로 개발을 해야 했다. 사실 받아서 보여주는 것 자체는 문제가 없는데, 데이터가 보이도록 html&css 조정을 하는 과정이 정말 오래 걸릴 것 같았기에 아쉽지만 이 기능은 일단 포기할 수밖에 없었다. (추후 구현할 생각 매우 있음..)\n\n30줄 안팎의 짧은 코드였기에 js 로 간단하게 구현했지만, 브라우저 객체를 처음 다뤄보는 거였기에 타입 명시를 할 수 없어서 아쉬웠다. 아마 파일이 한 개만 더 있었어도 ts로 구현했을 것이다.\n\n&nbsp;\n\n&nbsp;\n\n### _**시행착오 1**_\n\n객체를 다루며 놓친 부분이 있었는데, 할당 방식이었다.\n\n![](img5.png)\n\n위의 경우는 searchParams 에 set의 반환값인 Null이 할당되므로\n\n![](img6.png)\n\n위의 방식처럼 해야 URLSearchParams 객체가 생성되고 searchParams에 할당된 후에, set 을 통해 값 세팅이 정상적으로 될 수 있었다.\n\n### _**시행착오 2**_\n\njs 코드를 자꾸 리팩토링하면서 만지다 보니 에러가 발생했는데, 코드를 아무리 봐도 뭐가 잘못된 건지 모르겠어서 디버깅 방법이 있나 찾아봤다. 찾아보니 크롬 확장 프로그램 관리페이지에서 오류 디버깅이 가능했고, 보기도 쉽고 편했다.\n\n![](img7.png)\n\n에러를 확인해보니 set 함수에 들어가야 할 매개변수가 string 타입이어야 했기에 생긴 오류였다. 이것 역시 타입 지정 언어였으면 놓치지 않았을 버그여서 아쉬웠지만, 큰 문제는 아니어서 다행이었다.\n\n&nbsp;\n\n&nbsp;\n\n## _**기타 디자인(?) 요소**_\n\n![](img8.png)\n\n내가 만든 확장 프로그램은 기능도 생김새도 아주 간단하지만 내 형편없는 마크업 실력 덕분에 구현에 시간이 꽤 오래 소요되었다. 그래도 내가 직접 만들기에 고를 수 있는 사소한 요소들이 있어서 소소한 즐거움이 되어주었다.\n\n### _**아이콘**_\n\n프로그램 아이콘과 팝업 검색창 아이콘은 같은 모양으로 맞추고 싶었고, 이전에 쓰던 프로그램 아이콘이 다른 확장프로그램 아이콘들과 크기가 달랐기 때문에 전체적으로 통일감을 주기 위해 크기를 맞추고 싶었는데, 팝업 검색창 아이콘과 동일한 디자인의 정방형 아이콘을 찾을 수 없었다. 그래도 최종적으로 선택된 정방형 아이콘도 깔끔하고, 다른 아이콘들과 크기가 비슷해서 통일감이 생겼다.\n\n### _**색**_\n\n원래 유튜브 로고색은 너무 빨갛게 느껴져서 아이콘의 채도를 살짝 낮추었다.\n\n### _**검색창**_\n\n검색창 인풋도 원래는 좀 더 포커스를 주고 싶어서 외곽 볼드 처리를 했었는데, 커서가 움직이는 것도 나름의 포커스고, 기본 형태가 나은 것 같아서 뺐다.\n&nbsp;\n\n&nbsp;\n\n## _**소감**_\n\n이게 뭐라고 아주 뿌듯하고 너무 재밌었다. 오랫동안 해야지 해야지 생각했던 건데 몇시간 만에 만들 수 있었던 거면 진작 할걸 하는 생각도 들었다. 알고리즘 이지 난이도조차 안 되는 로직에 정말 기본적인 마크업으로만 구성된 프로그램이지만 하나부터 열까지 온전히 내 입맛에 맞출 수 있어서 개발 내내 너무 신났다. (간단한 거라서 그렇게 신났을 수도..) 꽤 오랜 기간 동안은 메뉴바의 아이콘만 봐도 뿌듯할 것 같단 생각이 든다.\n\n&nbsp;\n\n&nbsp;\n\n&nbsp;\n\n참조\n\n[Mozilla doc](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/manifest.json)\n\n[Chrome doc](https://developer.chrome.com/docs/extensions?hl=ko&_gl=1*14e8fz3*_up*MQ..*_ga*MTY4MDgxMTk5LjE3MTMyNzAyMzA.*_ga_H1Y3PXZW9Q*MTcxMzI3MDIyOS4xLjAuMTcxMzI3MDIyOS4wLjAuMA..)\n"},{"excerpt":"자바 아키텍처에는 3가지 구성요소가 있다.\n    \n  JDK(Java Development Kit) 자바 개발 키트는 자바 컴파일러, 디버거, 런타임 환경 등 자바 프로그램을 개발하고 실행하는데에 필요한 도구와 라이브러리를 제공한다. JRE(Java Runtime Environment) JVM 과 런타임 라이브러리 등으로 구성된 자바 어플리케이션을 실행…","fields":{"slug":"/understanding-jvm/"},"frontmatter":{"date":"April 15, 2024","title":"JVM 이해하기","tags":["Java"]},"rawMarkdownBody":"\n자바 아키텍처에는 3가지 구성요소가 있다.\n&nbsp;\n\n&nbsp;\n\n![](img1.png)\n&nbsp;\n\n### **JDK(Java Development Kit)**\n\n자바 개발 키트는 자바 컴파일러, 디버거, 런타임 환경 등 자바 프로그램을 개발하고 실행하는데에 필요한 도구와 라이브러리를 제공한다.\n\n### **JRE(Java Runtime Environment)**\n\nJVM 과 런타임 라이브러리 등으로 구성된 자바 어플리케이션을 실행할 환경이다.\n\n### **JVM(Java Virtual Machine)**\n\n**JVM(Java Virtual Machine, 자바 가상 기계)은 컴파일된 바이트 코드 파일을 운영체제에서 실행 가능한 기계어로 번역해서 실행할 수 있게 해주며, JRE(Java Runtime Env.) 의 일부**이다. 각 운영체제의 JVM 은 바이트 코드 파일을 해당 운영체제에서 실행 가능한 기계어로 번역해서 실행하기 때문에 **운영체제의 제약을 받지 않는 프로그램 개발이 가능**하다.\n&nbsp;\n\n&nbsp;\n\n이 중에서 오늘은 JVM 을 이해하는 것이 목적이다.\n&nbsp;\n\n&nbsp;\n\n![](img2.jpeg)\n\nJVM 에는 세가지 구성요소가 있다.\n\n1. 클래스로더 (Class Loader)\n2. 런타임 메모리 영역 (Runtime Data Area)\n3. 실행 엔진 (Execution Engine)\n\n## **클래스로더**\n\n클래스로더는 java.lang 패키지에 있는 추상 클래스로, .java 파일이 컴파일되어 바이트 코드를 포함한 동일한 이름을 가진 .class 파일이 생성되면 클래스로더가 .class 파일을 읽고 상응하는 이진 데이터를 생성해 JVM 내의 메서드 영역으로 동일한 이름의 클래스 파일을 로드한다.\n\n클래스로더는 **로딩(Loading) -> 링킹(Linking) -> 초기화(Initialization)** 의 순서로 작업을 수행한다.\n&nbsp;\n\n&nbsp;\n\n![](img3.png)\n\n### **로딩**\n\n클래스로더에는 몇가지 종류가 있으며 계층적으로 구성되어 있다.\n\n- 부트스트랩 클래스로더: **가장 먼저 실행되는 루트 클래스로더**로, $JAVA HOME/jre/lib directory 에서 표준 자바 패키지를 가져온다.\n- 익스텐션 클래스로더: 두번째로 실행되는 클래스로더로, 부트스트랩 클래스로더의 자식이자 어플리케이션 클래스로더의 부모이다. $JAVA_HOME/jre/lib/ext directory 에서 표준 자바 라이브러리를 가져온다.\n- 어플리케이션 클래스로더: 마지막으로 실행되는 클래스로더로, 익스텐션 클래스로더의 자식이다. 자바 어플리케이션 파일을 가져와서 실행한다.\n\n계층적 구조에 의해 클래스로더는 부모 클래스로더로부터 클래스를 로드하고 찾지 못할 경우 자식 클래스로더에게 로드를 위임하는 방식으로 동작한다. 이러한 클래스로더의 동작 방식은 **클래스의 중복 로딩을 방지하고 클래스 간의 의존성을 관리**하는 데에 도움이 된다.\n\n### **링킹**\n\n로딩 이후 클래스로더는 파일을 링킹한다. 이 과정에는 클래스로더가 파일을 검증, 준비, 해결하는 단계가 포함되어 있다.\n\n- 검증(verification): ByteCodeVerifier 라는 컴포넌트가 로딩된 .class 파일이 검증된 컴파일러에 의해 컴파일된건지, 구조가 유효한지 등을 검증한다. 검증이 실패하면 런타임 에러가 발생한다.\n- 준비(preparation): 만약 클래스에 인스턴스 요소나 정적 변수가 있다면 기본값을 할당한다.\n- 해결(resolution): 자바 클래스는 다른 클래스에 대한 참조를 포함할 수 있는데, 이러한 참조는 심볼릭 링크로 표현된다. 해결 과정에서 클래스로더는 심볼릭 링크를 직접적 링크로 대체한다.\n\n### **초기화**\n\n초기화 단계에서는 정적 변수를 초기화한다.\n&nbsp;\n\n&nbsp;\n\n---\n\n## **런타임 데이터 영역 (Runtime Data Area)**\n\n런타임 데이터 영역은 JVM 이 실행되는 동안 프로그램이 사용하는 데이터를 저장하는 메모리 영역으로,\n\n- 메서드 영역 (Method Area)\n- 힙 영역 (Heap Area)\n- 스택 영역 (Stack Area)\n- PC 레지스터 (Program Counter Register)\n- 네이티브 메서드 스택 (Native Method Stack) 의 다섯가지 영역으로 이루어져 있다.\n  &nbsp;\n\n  &nbsp;\n\n![](img4.jpeg)\n\n&nbsp;\n\n### **메서드 영역 (Method Area)**\n\n메서드, 필드, 상수 풀, 메타데이터 등의 클래스 정보를 저장하며, 모든 스레드가 공유하는 영역이다.\n\n런타임 상수 풀(Runtime Constant Pool) 이라는 자바 클래스 파일의 구성 요소가 존재하는데, 클래스 파일에 포함된 상수 풀(Constant Pool)의 런타임 버전이다. 즉, 클래스 파일에 정의된 상수들의 런타임 시점에서의 표현을 담고 있다. 자바 컴파일러가 소스 코드를 컴파일하여 클래스 파일을 생성할 때, 상수 풀은 클래스 파일에 상수 값들을 저장하고, 필요한 경우 런타임 중에 상수들을 참조하고 사용할 수 있도록 한다. 이를 통해 자바 프로그램은 동적으로 상수들을 참조하고 변경할 수 있다.\n&nbsp;\n\n&nbsp;\n\n### **힙 영역 (Heap Area)**\n\n![](img5.png)\n\n객체 인스턴스가 생성되는 영역으로, 동적으로 할당된 메모리를 저장한다. GC(Garbage Collection) 의 대상이 되는 메모리 영역으로, 더 이상 사용되지 않는 객체의 메모리를 회수한다. 힙 영역은 모든 스레드가 공유한다.\n\n- Young gen: 새롭게 생성된 클래스 인스턴스들이 저장된다.\n  - Eden: 새롭게 생성된 클래스 인스턴스들이 저장되는 곳으로, Eden 영역이 가득 차면, Minor GC(Garbage Collection) 가 발생하여 Eden 영역에 있는 살아있는 객체들을 체크하고, 살아남은 객체들은 Survivor 영역으로 이동된다. 이후 Eden 영역은 비워진다.\n  - Survivor: 이 영역에서 살아남은 객체들은 Old Generation 으로 이동될 수 있다.\n- Old gen: Young Gen 에서 일정 주기마다 살아남은 객체들이 이동하는 영역이다.\n\n  - 상대적으로 큰 메모리 공간을 가지고 있으며, 오랜 시간 동안 살아남은 객체들이 저장된다.\n  - Old Generation에 있는 객체들은 GC가 발생할 때마다 검사되며, 더 이상 참조되지 않는 객체들은 메모리에서 해제된다.\n\n&nbsp;\n\n### **스택 영역 (Stack Area)**\n\n메서드가 호출되면 새로운 스택 프레임이 생성되는데, 이 스택 프레임이 스택 영역에 저장된다. 메서드의 실행이 종료되거나 에러가 발생하면 스택에서 해당 프레임이 제거된다. 스택 영역은 각 스레드마다 하나씩 존재하며 스레드가 시작될 때 할당된다.\n\n### **PC 레지스터 (Program Counter Register)**\n\n현재 실행 중인 JVM 명령어의 주소를 저장한다. 각 스레드마다 별도로 할당되며, 스레드가 실행될 때마다 초기화된다.\n\n### **네이티브 메서드 스택 (Native Method Stack)**\n\n자바 외부에서 호출되는 네이티브 코드(C 나 C++ 로 작성된 코드) 를 실행하는 데에 사용되는 메모리 영역이다. 스택 영역과 마찬가지로 메서드를 호출할 때마다 해당 스택 프레임이 생성되며, 네이티브 메서드 실행이 종료되면 해당 스택 프레임이 제거된다.\n&nbsp;\n\n&nbsp;\n\n---\n\n## **실행 엔진 (Execution Engine)**\n\n실행 엔진은 JVM 내부에서 Java 바이트 코드를 해석하고 실행하는 역할을 하며\n\n- 인터프리터 (Interpreter)\n- JIT 컴파일러 (Just-In-Time Compiler)\n- GC (Garbage Collection) 으로 구성되어 있다.\n\n![](img6.png)\n\n### **인터프리터 (Interpreter)**\n\nJava 바이트 코드를 한 줄씩 읽어들여서 해당 코드를 직접 실행한다. 이 때문에 코드 실행 속도가 느릴 수 있다.\n\n### **JIT 컴파일러 (Just-In-Time Compiler)**\n\n인터프리터와 함께 사용된다. JIT 컴파일러는 인터프리터가 반복적으로 실행되는 코드를 감지하고, 해당 코드를 네이티브 기계 코드로 컴파일하여 최적화한다. 생성된 네이티브 코드는 캐시에 저장되어 동일한 코드가 실행될 때 재사용된다. 이를 통해 코드 실행 속도를 향상시킬 수 있다.\n\n### **GC (Garbage Collection)**\n\nGC는 JVM 에서 메모리 관리를 위해 사용되는 프로세스이다. GC는 주기적으로 메모리를 검사하여 사용되지 않는 객체를 식별하여 메모리를 해제한다. GC는 JVM 의 일부로 자동으로 실행되며, 개발자가 직접 관여할 필요가 없다.\n&nbsp;\n\n&nbsp;\n\n&nbsp;\n\n&nbsp;\n\n참조\n\nhttps://www.freecodecamp.org/news/jvm-tutorial-java-virtual-machine-architecture-explained-for-beginners/\nhttps://www.geeksforgeeks.org/jvm-works-jvm-architecture/\n"}]}},"pageContext":{}},"staticQueryHashes":[],"slicesMap":{}}